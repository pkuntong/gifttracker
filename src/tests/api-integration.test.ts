/**\n * API Integration Tests\n * \n * Tests for the enhanced API service including error handling,\n * caching, retry logic, and performance monitoring.\n */\n\nimport { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport { apiService } from '@/services/api';\nimport type { ApiError } from '@/types/api';\nimport { isApiError } from '@/utils/api-helpers';\n\n// Mock fetch for testing\nconst mockFetch = vi.fn();\nglobal.fetch = mockFetch;\n\ndescribe('API Service Integration', () => {\n  beforeEach(() => {\n    // Clear cache and tokens before each test\n    apiService.clearCache();\n    apiService.clearTokens();\n    mockFetch.mockClear();\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  describe('Authentication', () => {\n    it('should login successfully with valid credentials', async () => {\n      const mockResponse = {\n        user: {\n          id: '1',\n          email: 'test@example.com',\n          name: 'Test User',\n          created_at: new Date().toISOString(),\n        },\n        session: {\n          access_token: 'mock-token',\n          refresh_token: 'mock-refresh-token',\n        },\n      };\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: () => Promise.resolve({ data: mockResponse }),\n        headers: new Headers(),\n      });\n\n      const result = await apiService.login('test@example.com', 'password123');\n\n      expect(result.user.email).toBe('test@example.com');\n      expect(result.session.access_token).toBe('mock-token');\n      expect(mockFetch).toHaveBeenCalledWith(\n        expect.stringContaining('/api/auth/login'),\n        expect.objectContaining({\n          method: 'POST',\n          body: JSON.stringify({\n            email: 'test@example.com',\n            password: 'password123',\n          }),\n        })\n      );\n    });\n\n    it('should handle login errors gracefully', async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 401,\n        json: () => Promise.resolve({\n          message: 'Invalid credentials',\n          code: 'INVALID_CREDENTIALS',\n        }),\n        text: () => Promise.resolve(JSON.stringify({\n          message: 'Invalid credentials',\n          code: 'INVALID_CREDENTIALS',\n        })),\n        headers: new Headers(),\n      });\n\n      await expect(apiService.login('test@example.com', 'wrongpassword'))\n        .rejects.toThrow('Invalid credentials');\n    });\n\n    it('should validate email format', async () => {\n      await expect(apiService.login('invalid-email', 'password123'))\n        .rejects.toThrow('Please enter a valid email address');\n    });\n\n    it('should validate required fields', async () => {\n      await expect(apiService.login('', 'password123'))\n        .rejects.toThrow('Email is required');\n\n      await expect(apiService.login('test@example.com', ''))\n        .rejects.toThrow('Password is required');\n    });\n  });\n\n  describe('Data Management', () => {\n    beforeEach(() => {\n      // Mock authentication token\n      localStorage.setItem('auth_token', 'mock-token');\n    });\n\n    it('should fetch people with caching', async () => {\n      const mockPeople = [\n        {\n          id: '1',\n          name: 'John Doe',\n          email: 'john@example.com',\n          relationship: 'Friend',\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n        },\n      ];\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: () => Promise.resolve({ data: mockPeople }),\n        headers: new Headers(),\n      });\n\n      // First call should hit the API\n      const result1 = await apiService.getPeople();\n      expect(result1).toEqual(mockPeople);\n      expect(mockFetch).toHaveBeenCalledTimes(1);\n\n      // Second call should use cache (no additional API call)\n      const result2 = await apiService.getPeople();\n      expect(result2).toEqual(mockPeople);\n      expect(mockFetch).toHaveBeenCalledTimes(1); // Still only 1 call\n    });\n\n    it('should create person with validation', async () => {\n      const personData = {\n        name: 'Jane Smith',\n        email: 'jane@example.com',\n        relationship: 'Sister',\n      };\n\n      const mockResponse = {\n        id: '2',\n        ...personData,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n      };\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 201,\n        json: () => Promise.resolve({ data: mockResponse }),\n        headers: new Headers(),\n      });\n\n      const result = await apiService.createPerson(personData);\n      expect(result.name).toBe('Jane Smith');\n      expect(result.email).toBe('jane@example.com');\n    });\n\n    it('should validate person creation data', async () => {\n      await expect(apiService.createPerson({\n        name: '',\n        relationship: 'Friend',\n      })).rejects.toThrow('Name is required');\n\n      await expect(apiService.createPerson({\n        name: 'John Doe',\n        relationship: '',\n      })).rejects.toThrow('Relationship is required');\n\n      await expect(apiService.createPerson({\n        name: 'John Doe',\n        relationship: 'Friend',\n        email: 'invalid-email',\n      })).rejects.toThrow('Please enter a valid email address');\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle network errors', async () => {\n      mockFetch.mockRejectedValueOnce(new Error('Network error'));\n\n      await expect(apiService.getPeople())\n        .rejects.toThrow('Network error');\n    });\n\n    it('should handle 404 errors with fallback in development', async () => {\n      // Mock development environment\n      vi.stubEnv('DEV', true);\n\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n        json: () => Promise.resolve({ message: 'Not found' }),\n        text: () => Promise.resolve(JSON.stringify({ message: 'Not found' })),\n        headers: new Headers(),\n      });\n\n      const result = await apiService.getPeople();\n      \n      // Should return mock data in development\n      expect(Array.isArray(result)).toBe(true);\n      expect(result.length).toBeGreaterThan(0);\n    });\n\n    it('should handle rate limiting', async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 429,\n        json: () => Promise.resolve({\n          message: 'Rate limit exceeded',\n          code: 'RATE_LIMIT_EXCEEDED',\n        }),\n        text: () => Promise.resolve(JSON.stringify({\n          message: 'Rate limit exceeded',\n          code: 'RATE_LIMIT_EXCEEDED',\n        })),\n        headers: new Headers({ 'Retry-After': '60' }),\n      });\n\n      try {\n        await apiService.getPeople();\n        expect.fail('Should have thrown an error');\n      } catch (error) {\n        expect(isApiError(error)).toBe(true);\n        if (isApiError(error)) {\n          expect(error.status).toBe(429);\n          expect(error.code).toBe('RATE_LIMIT_EXCEEDED');\n        }\n      }\n    });\n  });\n\n  describe('Retry Logic', () => {\n    it('should retry failed requests', async () => {\n      // First call fails with 503\n      mockFetch\n        .mockResolvedValueOnce({\n          ok: false,\n          status: 503,\n          json: () => Promise.resolve({ message: 'Service unavailable' }),\n          text: () => Promise.resolve(JSON.stringify({ message: 'Service unavailable' })),\n          headers: new Headers(),\n        })\n        // Second call succeeds\n        .mockResolvedValueOnce({\n          ok: true,\n          status: 200,\n          json: () => Promise.resolve({ data: [] }),\n          headers: new Headers(),\n        });\n\n      const result = await apiService.getPeople();\n      expect(result).toEqual([]);\n      expect(mockFetch).toHaveBeenCalledTimes(2);\n    });\n\n    it('should not retry client errors', async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 400,\n        json: () => Promise.resolve({ message: 'Bad request' }),\n        text: () => Promise.resolve(JSON.stringify({ message: 'Bad request' })),\n        headers: new Headers(),\n      });\n\n      try {\n        await apiService.getPeople();\n        expect.fail('Should have thrown an error');\n      } catch (error) {\n        expect(isApiError(error)).toBe(true);\n        if (isApiError(error)) {\n          expect(error.status).toBe(400);\n        }\n      }\n\n      expect(mockFetch).toHaveBeenCalledTimes(1); // No retry for 4xx errors\n    });\n  });\n\n  describe('Performance Monitoring', () => {\n    it('should track request metrics', async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: () => Promise.resolve({ data: [] }),\n        headers: new Headers(),\n      });\n\n      await apiService.getPeople();\n\n      const metrics = apiService.getPerformanceMetrics();\n      expect(metrics).toHaveProperty('/api/people');\n      expect(metrics['/api/people'].totalRequests).toBe(1);\n      expect(metrics['/api/people'].avgTime).toBeGreaterThan(0);\n    });\n\n    it('should track error metrics', async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 500,\n        json: () => Promise.resolve({ message: 'Server error' }),\n        text: () => Promise.resolve(JSON.stringify({ message: 'Server error' })),\n        headers: new Headers(),\n      });\n\n      try {\n        await apiService.getPeople();\n      } catch {\n        // Expected error\n      }\n\n      const metrics = apiService.getPerformanceMetrics();\n      expect(metrics['/api/people'].successRate).toBeLessThan(1);\n    });\n  });\n\n  describe('Token Management', () => {\n    it('should handle token refresh on 401 errors', async () => {\n      // Mock initial 401 response\n      mockFetch\n        .mockResolvedValueOnce({\n          ok: false,\n          status: 401,\n          json: () => Promise.resolve({ message: 'Unauthorized' }),\n          text: () => Promise.resolve(JSON.stringify({ message: 'Unauthorized' })),\n          headers: new Headers(),\n        })\n        // Mock successful token refresh\n        .mockResolvedValueOnce({\n          ok: true,\n          status: 200,\n          json: () => Promise.resolve({\n            data: {\n              access_token: 'new-token',\n              refresh_token: 'new-refresh-token',\n            },\n          }),\n          headers: new Headers(),\n        })\n        // Mock successful retry with new token\n        .mockResolvedValueOnce({\n          ok: true,\n          status: 200,\n          json: () => Promise.resolve({ data: { valid: true } }),\n          headers: new Headers(),\n        });\n\n      // Set up refresh token\n      localStorage.setItem('refresh_token', 'old-refresh-token');\n\n      const result = await apiService.validateUser();\n      expect(result.valid).toBe(true);\n      expect(mockFetch).toHaveBeenCalledTimes(3); // Initial call, refresh, retry\n    });\n  });\n\n  describe('Cache Management', () => {\n    it('should clear cache manually', async () => {\n      mockFetch.mockResolvedValue({\n        ok: true,\n        status: 200,\n        json: () => Promise.resolve({ data: [] }),\n        headers: new Headers(),\n      });\n\n      // First call\n      await apiService.getPeople();\n      expect(mockFetch).toHaveBeenCalledTimes(1);\n\n      // Second call should use cache\n      await apiService.getPeople();\n      expect(mockFetch).toHaveBeenCalledTimes(1);\n\n      // Clear cache\n      apiService.clearCache();\n\n      // Third call should hit API again\n      await apiService.getPeople();\n      expect(mockFetch).toHaveBeenCalledTimes(2);\n    });\n  });\n});"